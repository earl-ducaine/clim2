


* Refactoring tk

** Allegro CL foreign interface (Motif library)
   All Allegro CL dependant Foreign interface stuff should be in this
   folder.  The following functions need to be wrapped

   - def-c-type
   - def-c-typedef
   - def-foreign-call
   - def-foreign-type
   - defun-foreign-callable
   - register-foreign-callable


** All ff functions appearing in project
   

** Raw list of ff functions
   Complete list of all ff functions that appear (possibly somm are
   never actualy used)

   - allocate-fobject
   - allocate-fobject-c
   - compile-foreign-type
   - convert-foreign-name
   - cstruct
   - cstruct-prop
   - cstruct-property-initialize
   - cstruct-property-length 
   - def-c-atype
   - def-c-type
   - def-c-typedef
   - def-foreign-call
   - def-foreign-type
   - defforeign-list 
   - defun-c-callable
   - defun-foreign-callable
   - euc-to-char*
   - foreign-address
   - foreign-pointer
   - foreign-pointer-address
   - free-fobject-c
   - fslot-address-typed
   - fslot-value
   - fslot-value-typed
   - get-entry-point
   - get-extern-data-address
   - make-cstruct
   - register-foreign-callable
   - sizeof-fobject
   - with-stack-fobject


** Steps for convesion

   Taking a new stab at this

   1. Create a wriapping package for alegro foreign function interface

      Below are the Allegro functions
      - foreign-pointer
      - foreign-pointer-address
      - def-c-atype
      - def-c-type
      - def-c-typedef
      - def-foreign-call
      - defun-foreign-callable
      - foreign-pointer-address

   2. Do some package magic to swap in to ff
   3. Create a test suite that stesses those functions used.
   4. Get test suite working with cffi
   5. Get clim2 working
   
** Steps for convesion (old)
   In general try tackle this in in a lower level to higher-level
   approach.  But a good start might be types, then structs, then
   functions, then classes?

   Strings might cause special problems because of the way that Motif
   prefers to be responsible for alocating and destroying them.

   1. Rename function with alist-<function-name>, e.g.
      allocate-fobject --> alisp-allocate-fobject

   2. Create a new function with the same name and signature that
      calls the old function, but can conditionally record calls for
      playback and can conditionall switch to the cffi implementation.

   3. Create a playback function that call the recorded script.

   4. Create cffi replacement and test that interface out.

   5. Refactor any incompatabilities.


** CFFI conversion

   All Allegro CL C foreign function calls should be wrapped in files
   called <alisp-fn>-wrapper.lisp.  The supcelia variable tk::use-cffi
   should be set to t and the project then recompiled.


** Files containing Allegro Foreign function calls

   aclpc/acl-class.lisp
   aclpc/acl-frames.lisp
   aclpc/acl-medium.lisp
   aclpc/acl-port.lisp
   aclpc/acl-prel.lisp
   aclpc/winwidgh.lisp
   tk-silica/ol-gadgets.lisp
   tk-silica/xm-gadgets.lisp
   tk-silica/xm-silica.lisp
   tk/callbacks.lisp
   tk/convenience.lisp
   tk/event.lisp
   tk/font.lisp
   tk/foreign-obj.lisp
   tk/foreign.lisp
   tk/gcontext.lisp
   tk/load-ol.lisp
   tk/macros.lisp
   tk/make-classes.lisp
   tk/meta-tk.lisp
   tk/ol-funs.lisp
   tk/resources.lisp
   tk/widget.lisp
   tk/xlib.lisp
   tk/xm-defs-wrapper.lisp
   tk/xm-defs.lisp
   tk/xm-funs.lisp
   tk/xt-defs.lisp
   tk/xt-funs.lisp
   utils/lisp-utilities.lisp
   wnn/jl-defs.lisp
   wnn/jl-funs.lisp
   xlib/def-exported-foreign-struct-cffi.lisp
   xlib/ffi.lisp
   xlib/load-xlib.lisp
   xlib/xlib-defs-lab.lisp
